# (PART) II  ROM hacking concepts {-}

An attempt has been made to divide sections up but you are advised not to pay that much attention to them, or at least do not consider them indivisible if for no other reason than just about any of these is the worthy of being the subject of a document longer than this one. Although it is the default position of this guide anyway this part will focus more upon the hardware underpinning things, any dominant formats/concepts and some basic techniques to use rather than simple tool usage (although much of that is covered too) with the next part being given over to fully worked examples rather than the simplistic techniques or overviews favoured in this section.

# Basics

This section contains some of the basic terms, concepts and ideas that will make ROM hacking and this document a bit easier to grasp. Before this starts though there are three equally important truths to know

1.  Any problem as far as “what does this represent?” goes can be solved.
2.  The bits you are looking at can mean anything and it is only with context you will figure out what they do in that instance.
3.  The bits might represent anything but any modern, non trivial system will layer things on top of each other in a process known as abstraction. Drill down or drill up as far as you need but there will usually be a limit where going further is just for intellectual curiosity and not much more.

## Hexadecimal

As you might know all current computers are binary machines, which is to say they operate on the idea of a reasonably continuous feed of of 1 and 0 values to various pins to do what needs to be done. 1 and 0 get very hard to read so these are stacked up 4 deep to form hexadecimal (a very similar logic to writing things like 1x10^9 instead of 1000000000). 4 things each with the ability to be one of two different states means 16 combinations, and as it is then desirable to be able to display each combination as a single character the letters A through F join the Arabic numbers (0 through 9) to make 16 (A=10 decimal, B=11 and so on to F=15 at which time it wraps around and 10=16 decimal).

A quick reference table

|     |     |     |
| --- | --- | --- |
| * * * | * * * | * * * |
| Decimal | Hexadecimal | Binary |
| * * * | * * * | * * * |
| * * * | * * * | * * * |
| 0   | 0   | 0000 |
| * * * | * * * | * * * |
| 1   | 1   | 0001 |
| * * * | * * * | * * * |
| 2   | 2   | 0010 |
| * * * | * * * | * * * |
| 3   | 3   | 0011 |
| * * * | * * * | * * * |
| 4   | 4   | 0100 |
| * * * | * * * | * * * |
| 5   | 5   | 0101 |
| * * * | * * * | * * * |
| 6   | 6   | 0110 |
| * * * | * * * | * * * |
| 7   | 7   | 0111 |
| * * * | * * * | * * * |
| 8   | 8   | 1000 |
| * * * | * * * | * * * |
| 9   | 9   | 1001 |
| * * * | * * * | * * * |
| 10  | A   | 1010 |
| * * * | * * * | * * * |
| 11  | B   | 1011 |
| * * * | * * * | * * * |
| 12  | C   | 1100 |
| * * * | * * * | * * * |
| 13  | D   | 1101 |
| * * * | * * * | * * * |
| 14  | E   | 1110 |
| * * * | * * * | * * * |
| 15  | F   | 1111 |
| * * * | * * * | * * * |

The thing to remember about binary is that it is much like the number 1567 decimal means 1 count of 1000, 5 counts of 100, 6 counts of 10 and 7 counts of 1 or in words it is a list of counts of ten raised to a power. For binary rather than ten you use 2 so 1110 means one count of 8, one count of 4, one count of 2 and zero counts of 1. There are all sorts of tricks and things you can learn here, many of which will be covered before long, and some are almost as essential as hexadecimal when it comes to understanding the document to come.

You can learn to convert it and do maths with it in your head if you like and it is certainly a useful skill, however most of the time you will just be finding the value (in which case a program will probably be doing it) and everything from windows bundled calculator (in scientific mode) upwards will convert between the various bases (base10= decimal, base2= binary, base16=hexadecimal) and be able to perform maths with it.

There is a fourth method called Octal aka base 8 that uses 0 through 7 and represents 3 bits but 3 is a terrible number to work with and multiply with (it being a prime number and all) so it tends not to be used outside of specific applications. There are further variations on this theme in things like Base64 but that is an encoding scheme for transmission of data and will be covered later in text hacking.

In summary hex(adecimal) is just a numbering scheme that works better than regular decimal for computing purposes and nothing more. Quite often new hackers are seen to assign a near magical status to hexadecimal, and by extension hex editors, when it really deserves nothing of the sort; the magical stuff is assembly hacking. Certainly it is very hard to take a look at an entire ROM and edit it just from a hex editor which is why nobody does it from scratch, if they appear to then it is almost certain they either did a lot of work to get to that point (there are many programs that will spit out locations and interesting values). Putting in the time to reverse engineer the original work is what ultimately allowed for the simple edit, failing that the file conforms to a known standard (open up any proper DS ROM and the first line will be a ASCII encoded text string of the internal name of the ROM and there are similar things for most DS files/formats) or enough of a standard that a basic edit is possible.

### 1.1.1 Representation

There is a very overdone computing joke along the lines of there are 10 kinds of people in the world (those that know binary and those that do not).

As said “joke” just illustrated it is hard or even impossible to know what set of numbers is being used. As you can take down an entire system with an errant bit, let alone a complete misinterpretation, there needs to be a way to indicate what is being used. In mathematics a subscript decimal value of the base you are using is used but that is awkward to write in a basic text editor so various notations have been used. The most common ones being 0x???????? (sometimes the 0x is repeated after so many values but not always), ????????h/h????????, #???????? (this is the way HTML does it but not so many ROM hackers will use it), %???????? (this is the way your browser probably signifies it with %20 for example being the ASCII text encoding for a space) or simply ???????? hex. Most people are quite happy to accept a bit of redundancy in exchange for a lack of confusion here.

Stick two hexadecimal numbers together (sometimes called nibbles/nybbles) and you have a byte. From there it can stack further although it can get a bit tricky as it varies between computer architectures (32 vs 64 bit for instance), operating systems and sometimes programming languages. In general most people will stick to the 32 bit C programming language interpretations of all this and that is what this document will be using unless otherwise stated.

Going further the terms halfword, word, double word (dword), quad word, short, long and int are what is interesting and are probably worth knowing.

Most of the time it follows on from bytes with half word being 16 bits aka 2 bytes, words being 32 bits aka 4 bytes, dwords being 64 bits and so on. In ROM hacking few people will use the terms short and long and especially not the term “int” as the “bit” of the processor in question will vary this, the main exception being if they are defining a format in a similar manner used in a programming language (in which case uint for unsigned integer, u8, u16 and similar things appear). If you do go looking “typedef” is the usual catch all term to describe this sort of thing, and many programming tutorials will quite rightly spend a lot of time covering these concepts. In many ways it is not that useful to ROM hacking until you get to analysing what might have happened in the original source to get to here, at this point you probably already know the/a programming language.

An important extra term when discussing this is boundary/alignment. Unless you are writing poetry you probably do not have to make your sentences a given number of letters/words but computers tend to like it more if the data starts on a multiple of a given value (sometimes it might be "byte aligned" but more often it is word aligned or even higher[1](romhacking20202.html#fn1x0) ) or involves manipulating a given length of memory (various internal functions of the DS and GBA prefer to only operate on similarly aligned sections of memory).

One link that has some good stuff if you want to go further is the [art of assembly](http://www.plantation-productions.com/Webster/www.artofasm.com/Windows/HTML/DataRepresentation.html#998834) but if things are preferred a little closer to conventional maths [grinnell.edu](http://www.cs.grinnell.edu/~rebelsky/Courses/CS152/97F/Readings/student-binary.html) have a nice page.

### 1.1.2 BCD (Binary coded decimal)

Mentioned mainly as it is a nice example on how binary and hex mean very little without context. It is seen in one place on the DS in the firmware and things stemming from it (mainly the clock and calendar functions) as well as older programs, for a while certain processors even had functions in their silicon for it, but it is rarely seen when hacking ROM images these days.

There some minor variations here (the standard 8,4,2 and 1 can make every combination between 0 and 9 but so can 5,3,1 and -1) but they are not commonly seen. As mentioned the standard method is the same as the translation of binary to hexadecimal so bringing back the table with only the relevant entries.

|     |     |     |
| --- | --- | --- |
| * * * | * * * | * * * |
| Decimal | Hexadecimal | Binary |
| * * * | * * * | * * * |
| * * * | * * * | * * * |
| 0   | 0   | 0000 |
| * * * | * * * | * * * |
| 1   | 1   | 0001 |
| * * * | * * * | * * * |
| 2   | 2   | 0010 |
| * * * | * * * | * * * |
| 3   | 3   | 0011 |
| * * * | * * * | * * * |
| 4   | 4   | 0100 |
| * * * | * * * | * * * |
| 5   | 5   | 0101 |
| * * * | * * * | * * * |
| 6   | 6   | 0110 |
| * * * | * * * | * * * |
| 7   | 7   | 0111 |
| * * * | * * * | * * * |
| 8   | 8   | 1000 |
| * * * | * * * | * * * |
| 9   | 9   | 1001 |
| * * * | * * * | * * * |

Using the clock example if you wanted to represent the time 15:30 you could figure out a way to encode it or just use BCD

0001 0101 0011 0000 which has a decimal equivalent of 5424 (not 1530) but can quite happily represent the time.

For a quick example of the 5,3,1 and -1 scheme also mentioned

|     |     |     |
| --- | --- | --- |
| * * * | * * * | * * * |
| Decimal | Hexadecimal | Binary |
| * * * | * * * | * * * |
| * * * | * * * | * * * |
| 0   | 0   | 0000 |
| * * * | * * * | * * * |
| 1   | 1   | 0010 |
| * * * | * * * | * * * |
| 2   | 2   | 0101 |
| * * * | * * * | * * * |
| 3   | 3   | 0100 |
| * * * | * * * | * * * |
| 4   | 4   | 1001 or 0110 |
| * * * | * * * | * * * |
| 5   | 5   | 1000 |
| * * * | * * * | * * * |
| 6   | 6   | 1010 |
| * * * | * * * | * * * |
| 7   | 7   | 1101 |
| * * * | * * * | * * * |
| 8   | 8   | 1100 |
| * * * | * * * | * * * |
| 9   | 9   | 1110 |
| * * * | * * * | * * * |

15:30 once more

0010 1000 0100 0000 which has a decimal equivalent of 10304 but according to the scheme above will decode as 1530.

There have been cases of things using it to display fractional values which can be useful as there are certain common things plain hexadecimal struggles with.

### 1.1.3 Big and little endian

Absolutely vital when dealing with the GBA and DS in any real depth is the concept of endianness. Historical reasons are the main reasons for it existing in the first place although it does have value still, and as many systems use it the aspiring ROM hacker has to know about it. In short where the conventional maths and devices with X86 family chips (most PCs) display the most significant number first devices using ARM chips (and many others) which include the GBA and DS display the least significant bytes first.

In practice it means some locations/lengths might be written as something like A036 0104 when in fact they read 0401 36A0. Although many hex editors will support a change between big and little endian the process by which most of it is rendered readable is usually a flip across so many bits (32 bit flip means 32 bits as above will be flipped, 16 bit flip means only two bytes will be flipped).

Seen as most people code on a PC, or a device that is emulating a PC setup, it is far from unheard of for a device to see a format use the opposite type of endian to what it is.

### 1.1.4 Signed values, floating point and fixed point

There is also the matter of signed bytes and (floating) point values for as with computers not being able to easily write subscript they tend not to have provisions for negative symbols and values after the “decimal” point either. Do note that some of these methods have since made their way into silicon as well, though the GBA and DS are somewhat lacking here.

Signed values Various methods exist here with popular ones including ones complement, twos complement and excess 7. Each have advantages and some disadvantages depending upon what you are doing although the biggest disadvantages to some of the simpler methods are the inability to do simple maths without conversion and the existence of two values for 0 which makes comparing and acting on the results tricky.

Signed numbers are also one of the reasons for some stats ending at 511 or 127 or similar (it should become apparent why this is very shortly) with the other big reason, assuming the first bit is not simply ignored, is that programmers frequently like using the first bit to encode something or act as a flag of some form (for instance the DS archive format NARC uses it so signify a subdirectory). For another source on the subject [grinnell.edu’s CS152 has a nice version](http://www.cs.grinnell.edu/~rebelsky/Courses/CS152/97F/Readings/student-binary.html).

Sign and magnitude Here the first bit of a value is given over and called a negative flag which is also another name for the method (although the term can be used more generally when dealing with signed numbers), another name is signed magnitude.

Here the first bit is given over to being a sign with the rest of the numbers being interpreted as usual. It is the most similar method to conventional counting/maths. 0 means positive while 1 means negative. 0000 0001 equals 1 and 1000 0001 equals -1

Ones complement For the ones complement a bitwise NOT operation (covered in more detail later but in short it changes every 0 into a 1 and every 1 into a 0) is applied to a positive number making the negative counterpart. It has problems as basic maths can not be done so easily and it has the problem of two values for 0.

0001 becomes 1110

0010 becomes 1101

0011 becomes 1100

Twos complement Marginally more complex than the others mentioned so far is twos complement but as it does not have the pitfalls of the other numbers (two representations of zero and simple maths is possible) it is popular. Here the ones complement is made (bitwise NOT to all the digits) and then 1 is added to the result using conventional binary addition. 0000 becomes 1111 and then 0001 0000 but the other part is ignored.

Examples

Example 1

-1

Postive one is 0001

NOT gives 1110

adding 0001 gives 1111

Example 2

-3

Positive three is 0011

A bitwise NOT gives 1100

Adding one 0001 gives 1101

Maths example

Similar to the example of 0 above 2 decimal (0010) added to -1 (1111) which gives 0001 0001 and has the leftmost “spillover” ignored.

“Excess 7” Although twos complement and the others will serve you well and form the bulk of everything you come into contact with there is another somewhat more complex method in common use. It can vary a bit depending upon your implementation (the technical/concept name is excess 2^(m-1) where m is the number or binary digits you have to work with) but excess 7 will be used for now.

It becomes more complex and somewhat more important when fractional numbers arise (covered in the section below). In practice it is a kind of combination of the basic signed magnitude idea and twos compliment. As mentioned this is sticking with excess 7 for the example but scaling up is fairly logical.

In this system the the first bit is used to indicate the sign (although not necessarily the sign of the final number) leaving the remaining 7 (excess 7) to do what needs to be done. So far not very different to anything covered but this is where the trick happens although an example before it is covered in earnest.

In years past you might have been encouraged to just make numbers huge as a workaround for having to deal with negative numbers.

The equation

![8 - 1- 3+ 6 +9 = 19
](images/romhacking20200x.png)

A simple equation but with a calculator or in your head it is quite possible to make a mistake and mess the whole thing up.

Adding in this case ten to all the numbers makes them all positive

![18+ 9 +7 + 16+ 19 = 69
](images/romhacking20201x.png)

Five numbers all 10 larger makes the result “out” by 50 but plain addition is far easier to avoid making a mistake in.

The reason for the digression to simple maths tricks is a similar principle gets used for excess 7.

In the case of the excess 7 (also called 8 bit excess 127) this is usually 01111111 or 127 in decimal. Here the value you want to encode is either taken (positive numbers) or added to (negative numbers) from this value. In theory, and so probably somewhere in a game out there, the excess does not have to be 127.

If you prefer it could be seen as counting starting at the lowest possible number which would be “-(-1 +2^m)” or for 8 bits “-(-1 + 2^7)” which is negative 127 and call that the starting / “zero” value. 0 (as in nought) is then the bias value. It has the advantage of being easily compared with other numbers so it is worth knowing about.

Examples

Number to encode -7 or (-) 0000 0111

0111 1111 – 0000 0111 = 0111 1000

Number to encode 18 or 0001 0010

0111 1111 + 0001 0010 = 1001 0001

Examples

0000 0000 -127

0000 0001 -126

0000 0010 -125

0111 1111 0

1000 0000 +1

1000 0001 1111 1111 +128

In practice/the real world this is covered by the near universal standard IEEE 754 which is more commonly seen when dealing with floating point numbers. You could make another method but nobody really does and hardware is built to use it so again nobody does, give or take a few things using fixed point numbers. Here 32bits or more can be used with the first being the sign, the next being the bias value and the rest being the encoded number in question. Speaking of fractional numbers though

Fractional numbers and real numbers Fractional numbers are usually done using a so called “floating point”, however the GBA and DS do make extensive use of fixed point numbers for various parts of the hardware including 2d transformations and 3d and will be covered shortly. The idea of leaving things as values and only calculating them at the last moment is encouraged in programming but in hardware or the final representation this can be tricky and as that is where ROM hackers spend most of their time it will be noted and nothing much else said on the subject.

Floating point On the face of it floating point appears related to the excess 7 method of displaying signed numbers, in practice it is actually closer to the standard scientific notation for displaying large numbers. The concept of this then is the idea of floating point numbers, in essence they are

1.  A sign value
2.  A multiplier (actually an exponent) to make sure the “decimal” point gets where it needs to be
3.  The number itself but without the 1 part as that is assumed to be 1 so as to be able to save a bit.

For 3. above much like you would never write 0.31x10^-3, unless you are an engineer where the used powers are usually a multiple of three, it is always assumed the first bit is 1, as you are working in binary that means the only value it can be is 1 and you can leave it out of the number that is transmitted as long as you remember to reconstruct it.

It probably does not take a great leap of imagination to see how this gets very complex to operate with multiple values (different “powers” or not) very fast. To this end even though most software development kits and systems will feature abilities to handle such things their use is ideally saved for when there is no other option, indeed newer/high performance systems often have their computer power compared by how many flops (floating point operations per second) or indeed criticised on their lack of support for various versions of floating point (single precision, double precision.....). Unlike binary and hexadecimal above the ability to decode it is something you should be able to run through but most will expect you to use tools to handle it.

There is a class of compression based on this idea known as arithmetic coding. It works on the idea that for the file might represent it is still a number and some numbers can can be represented shorter by encoding them as a floating point.

The short version

32 bits long the first bit is the sign of the multiplier, the next 8 bits are the value of the exponent of the multiplier in excess 7 notation and the final bits are the basic value that needs multiplying save for the “hidden” 1 value which the fractional part gets added to.

That is a bit wordy so examples

Decoding 40a4cccd hex

The binary representation is as follows

0100 0000 1010 0100 1100 1100 1100 1101

0 starting means it is positive.

The excess 7 bits

1000 0001

0111 1111 + ???? ???? = 1000 0001

???? ???? = 0000 0010 = 2 decimal (leading to 2^2 or 4)

Taking the remaining section and adding the invisible 1

1010 0100 1100 1100 1100 1101

Much like binary is powers of two the fractional part goes the other way and decreases in powers of two so taking that pattern and checking off the pattern against it.

1 0 0.25 0 0 0.03125 and so on

Using just the numbers there 1.28125

Multiplying by 4 gives 5.125

Short of the actual number it is supposed to represent which is 5.15 but if you continued adding numbers from the binary pattern it would get very near there.

Representing 3.14

Positive so first is 0

Dividing by 2 renders it as 1. something and 2^1 = 2

2 in excess 7 is 10000000

0.57 is the number that needs representing.

0.5 + 0 + 0 + 0.0625 and so on

For now stopping there

10010000000000000000000

Working back through leaves it at

01000000010010000000000000000000 binary or 4048 0000 hex

Decoding that though gives 3.125 so the pattern should have been continued further

In practice it ends up as

10010001111010111000011

Which combined with the rest gives

4048f5c3 hex.

The slightly longer version

Single precision (32 bits) and double precision (64 bits) are the most common versions of floating point with anything beyond that (save perhaps quad precision in some hardware) usually being relegated to (very slow) software methods.

Also the exponent values in theory at least range from -126 to 127 (00000001 and 11111110) meaning the all 0 and the all 1 values are not available. In practice these are used as follows

0

All 0 indicates exact 0 or more accurately values smaller than the lowest feasible value.

1

All 1 indicates either positive or negative infinity for the all 1 values assuming the mantissa section has nothing in it. If the mantissa does have something in it then it means an error like divide by 0 or something similar (NaN aka not a number).

For more [IEEE floating-point representations of real numbers](http://www.math.grin.edu/~rebelsky/Courses/152/97F/Readings/IEEE-reals.html)has a basic overview and [What Every Computer Scientist Should Know About Floating-Point Arithmetic](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html) has a far more in depth discussion and historical analysis. If you just want something to toy with to get it sorted in your head [FloatConverter](http://www.h-schmidt.net/FloatConverter/IEEE754.html) is quite good.

To make up for some of the shortcomings of the method there are two common functions that are used when dealing with such things.

Ceiling In short round up to a given value (or multiple thereof) regardless of what a conventional round would do. Not necessarily limited to fractional numbers either.

Floor In short round down to a given value regardless of what a conventional round would do. Also not necessarily limited to fractional numbers.

Fixed point values Floating point is used everywhere in computing (especially in 3d and mapping of things in 3d, something you may have seen the occasional game do) and it is quite costly in terms of resources so fixed point appears.

Fixed point attempts to work around some of the issues with floating point at the potential cost of some accuracy and some flexibility. It is seen in parts of the DS 3d system among other things where 4 bits “natural number” 12 bits “fractional” is often of the order of the day. That is to say the computer assumes all numbers after a given binary digit are fractional. Some instead prefer to view it as a range type function with 0000 to 1111 representing the difference between two whole numbers (or in the case of sine and cosine -1 to 1).

Timers are quite commonly made like this although they can also just be a multiple, the “timer” used for the DS SSEQ audio format being a good example of the latter.

What the numbers mean is usually either the logical extension of the binary “powers” (2^-1=0.5 decimal, 2^-2 = 0.25 decimal.....) or they count again and the number after the point is effectively assumed to be a normal number. Binary coded decimal, almost invariably in the 8421 arrangement, can also appear here.

As with signed values their use prevents the number from being read as a simple integer and used in simple maths although with a bit of shifting, rotating and such you can get quite a bit done and even do some basic comparing and maths. Speaking of shifting and rotating

## Hex operations

Hexadecimal is just numbering but there are common things done to it that file formats use, the internal logic of the computer will use and can be used to quickly and easily manipulate something that needs manipulating.

### 1.2.1 Shift

Right hand and left hand shift are useful when you need to chop off a bit from a value, you need to generate a value where you can not fit it into a smaller length than the destination or in some formats which leave things in an unshifted form for whatever reason. In practice 32 bits allows for a lot of address and 31 bits can still quite easily handle most GBA and DS addressing needs so the upper bit can be used to indicate things, as indeed NARC files do so as to indicate a subdirectory. Moreover lots of the DS internals only need a few bits for things they do so they are combined with other sometimes unrelated things which you might need to lose to see what is going on. In a hex editor you would probably be better advised to use Boolean logic (covered in a moment) rather than shifts but in hardware it can go either way.

A shift can be right hand (you shift the numbers to the right losing the leftmost piece of data) or you shift to the left losing the rightmost piece of data.

It is also useful as a quick multiplier; think how you technically shift the numbers when you multiply or divide by 10 in decimal, albeit here you multiply or divide by 2 instead.

There is also the distinction of logical shift and arithmetic shift where in the case of the latter you do not lose the data if you shift left and then shift right. You can also do block shifts but they are just a special case which usually means a given number of bits are shifted.

### 1.2.2 Rotate

Related to shift but where you lose data if you shift it appears in the other side when you rotate.

1011 rotates left by 1 bit makes 0111

### 1.2.3 Flip

Flip is most useful when you are working around big and little endian. It was already seen when big and little endian were covered above but a 32 bit flip of A036 0104 reads 0401 36A0.

In some cases it can be useful to flip larger or smaller values, for instance although many formats will use a full 32 bits for a length the file might be very short and only need the first 16 bits. More useful (and not often a function of hex editors) the GBA 4BPP image format uses 4 bits per pixel but will flip them between storage and being on the screen.

In the figure below you can see the hex that represents the highlighted tile (it is the icon from the wifi version of Yakuman DS, a competitive Mahjong title).

* In the first line you can see 0000 D0DD where the pink pixels (in practice they would be transparent but more on that when graphics are discussed) which are represented by 0 in this case run for 5 pixels.
* In the next line you can see 4 pink pixels as they are but then the grey pixel (in this case D) is after the F value which represents the white pixel
* In the next line you can see the cream coloured pixel (E) be second to last as opposed to actually last. It it done because that is how the hardware works/expects things but it can make it tricky if you are trying to simply edit it.

![PIC](images/0_home_fast6191_romhackingguide_unrenamed_files_and_original_borders_romhackingendiandemo.png)

### 1.2.4 Boolean logic

Often a more useful set of techniques than basic shifts and the other operations covered already. There are several types although you will probably see patterns soon enough (mainly that the NAND, NOR and XNOR are just the inverse of their counterparts). Boolean logic exists in two big areas ROM hacking and related pursuits might be concerned with; one is programming and the other is electronic logic where they perform identical functions but in some ways are thought of a bit differently.

Here is probably useful to discuss the idea of high and low as it applies to computing and electronics. In the vast majority of cases (especially software and ROM hacking) you should always assume that unless otherwise stated a high value corresponds to 1 and a low value corresponds to 0. This is unlike some other things in this section where you will usually want to seek clarification for things (what method of negative or point numbers you are using for instance). There is however a variation on this called negative edge logic (referring to certain chips that change on the falling edge of a clock pulse) that can be described with the opposite where 0 is high and 1 is low.

Examples will be done in binary.

NOT aka inverse Does what it says and flips every bit.

1001 1110 becomes 0110 0001

AND Here you take two numbers (preferably of equal length but if not the shorter sequence is repeated as appropriate in most cases) and combine the outcome so that only if both inputs are high the result is high

1100 1111 AND 1010 0100 becomes 1000 0100

NAND Much like AND you take two numbers and put them together but rather than if both are high this is if both are low. It is most useful as it is a fundamental logic operation; you can stack NAND operations or indeed NAND gates in such a way that you can make any other Boolean operation.

1100 1111 NAND 1010 0100 becomes 0111 1011

OR Again two numbers but if any one of the inputs it high the result is high.

1100 1111 OR 1010 0100 becomes 1110 1111

NOR Two numbers but only high if both inputs are low

1100 1111 NOR 1010 0100 becomes 0001 0000

XOR Two numbers but only high if only one input is high. Useful as encryption by itself and the basis of many more useful encryption methods. As a quick aside there are serious downsides when it comes to actually being used as encryption, if done properly it is one of the few that can not be broken with enough computing power. Also where the others can easily have multiple inputs in electronics a multiple input XOR is tricky at best.

1100 1111 XOR 1010 0100 becomes 0110 1011

XNOR Two inputs, only high outputs when none or both inputs are the same. Being the inverse of XOR it has similar problems to it.

1100 1111 XNOR 1010 0100 becomes 1001 0100

Discussion of Boolean logic. The most useful in day to day ROM hacking are probably NOT, AND, OR and, purely because of the encryption, XOR.

NOT aka inverse is useful on many occasions for many things especially in graphics (it might not be quite that simple in practice but inverting colours is quite common). Also useful to corrupt data and recover it easily (you just invert it back).

AND is useful to remove certain bits, for instance if you want to remove the highest bit in a byte just AND the result with 0111 1111 and whatever the rest is will stay the same but the highest bit will be 0 regardless.

OR is useful if you want to set a certain bit high, for instance to set the highest bit in a byte high just OR the result with 1000 0000 and the first bit will be set high regardless but the rest will only be high if they were to begin with.

XOR is also used a few times in the internals of the GBA and DS and is used extensively as simple protection at points in cheat devices and things like the GBA e reader.

An aside on logical/relational operators They share the same name and broad function as the boolean logic but here they are used as checks to see if both inputs meet a given condition. In C type languages it runs as follows

AND checks to see if both inputs are non 0 and returns true if it is the case

OR checks to see if just one input is non 0 and returns true if it is the case

NOT merely reverses the output of the other functions.

As far as most of ROM hacking is concerned this will usually be interpreted closer to assembly where compares and branching will be used instead.

Equally a right hand logical shift is different from a conventional right hand shift in that it will retain the most significant bit

1000 1110 right shifted by 1 makes for 1100 0111

### 1.2.5 Hex Mathematics.

Some people can operate in hexadecimal but most of the time the maths resembles long division and long form maths. It is quite useful to know as... quickfire round what is 9 + 3 in hex.

The answer is C but courtesy of probably using decimal all your life your immediate thought might well have been 12 which could well mess your entire hack up if you put that into the ROM.

Subtraction works much the same way until you get to negative (signed) numbers in which case you get to figure out what method you are using for it.

Multiplication is easy enough

1D x 09 is 10 x 9 + 0D x 9 or 90 + 75 = 105

Division is a pain and more importantly depends on the programming language function used; many basic methods will chop off the stuff after the “decimal” point where others will turn it into a floating number. Floating point might not be that accurate as hex is somewhat less capable of displaying the results of common divisions, not to mention it will be rounded at some point. Such a trick is often used to confuse, and so teach, new programmers and even catches out older ones; finance packages are especially troubled by this for if they miss a couple of rounding points it can result in big amounts of money not going where it needs to go. There are however a few concepts worth noting as they crop up in programming languages and the processors they run on

Mod As mentioned some basic hexadecimal divide functions will leave you with just the whole number part of the result (99 divided by 6 is 16.5 but many divide functions would just give you 16). Mod is then a function that gives you the remainder as a whole number (99 divided by 6 is 16 remainder 3) which you can leave in the hope it will be multiplied back later or feed to another command (many divide functions struggle with large numbers and prefer small ones).

Abs(olute) Potentially confusingly regular maths sometimes also calls this modulus with the shorthand sometimes being “mod”. Depending upon how far you want to take maths it can get quite complex but the short version is abs value of a number is just the number (always positive) without the sign. It is then quite useful to feed into functions so you can simplify them or the resulting maths.

## Patching and patch making

ROM hackers change ROM images, copyright lengths being what they are it means such things are copyrighted code. Even edited code still has protections so the differences between the versions are found and made into a patch file, such a thing will also have the very nice bonus of tending to be far smaller and easier to transmit. Patch files then allow someone to take the original ROM, apply the patch to turn it into your changed version and then play it. As with most concepts you can use a computer to help out and, also like most concepts, there many methods by which you can create and apply patches. However unlike most other times where you need to decide between competing formats there is more to it than token differences and vendor lock in. Each type is linked to the best example/implementation at time of writing with a couple more at the end if there are others worth noting.

* [IPS](https://www.romhacking.net/utilities/13/). The original ROM hacking patching method of choice. It is a truly basic format (the basic form contains a magic stamp/value, a list of patches to apply (which consist of a location, length and payload) and a signal for the end of the file) although there are a few custom versions that are not widely supported. It can not handle location changes which is not a problem for older consoles but with consoles that have filesystems (which is to say most optical media using and post GBA consoles) it is a dealbreaker. It is also limited to files of 16 megabytes in size or less, again this is not a problem on older consoles but even the GBA allowed code up to 32 megabytes to be run.
* [UPS](http://www.romhacking.net/utilities/519/). Made as a direct successor to IPS it has found some use in older consoles and later GBA patches but came a bit too late and the patching methods below had stolen the spotlight. [Upset](http://www.romhacking.net/utilities/677/%20), [Tsukuyomi UPS](http://www.romhacking.net/utilities/519/) and [NUPS](http://www.romhacking.net/utilities/606/) are all good tools for UPS.
* [PPF](http://www.romhacking.net/utilities/514/). Made originally to patch PS1 games (Playstation Patching Format being the longer form) it went through a few revisions and as such some are wary, however it saw some use on the Wii and continues to kick around. Size limits are not really a problem (it is unknown what the upper limit is) and shifts are handled OK. [PPF-O-Matic](http://filetrip.net/pc-downloads/applications/download-ppf-o-matic-30-f29416.html) is a nice GUI patching program and the original [PPF](http://www.romhacking.net/utilities/353/) program should provide a nice multiplatform patching and patch making alternative.
* [Xdelta](http://xdelta.org/)and [BSDiff](http://www.daemonology.net/bsdiff/). Both general patching formats (indeed they tend to position themselves as rival formats) that got used for the DS and newer consoles (ROM hackers have tended to favour Xdelta where BSDiff saw more use in the form of Scene trainers and patches). Shifts are handled well enough (although they might not be perfect) and sizes are not likely to get to a limit any time soon (although some implementations of BSDiff are rather low). Features some support for original file checking and hashing. The current version of Xdelta was linked but there is an [older version](http://www.evanjones.ca/software/xdelta-win32.html) that was used for a while and there have been some compatibility issues.
* [Ninja](http://www.romhacking.net/utilities/329/). An earlier candidate to replace IPS and fell out of favour for various reasons. Some patches have been seen to use it and in many ways it works quite well.
* [PAR2](http://www.quickpar.org.uk/). Not a patching method per se and more of a corruption detection and data recovery format. Changed data is no different to corrupt data as far as it is concerned so can patch programs though it has some trouble with data shifts. Better yet though assuming you have enough redundancy you can be certain your patch will make the original ROM into exactly what you need which is quite useful when there are various corrupt or otherwise modified dumps out in the wild (headers on SNES ROM files for instance).
* Custom. There were some other formats made for various things (Jump Super Stars for instance) and others aimed at more specific things (Fireflower is a patching format aimed at certain graphics hacks for instance) but those will not really be covered here. Some people decided to unpack the ISO/ROM files, patch those individually and build a ROM/ISO afterwards. This made for the smallest patch sizes, usually got around the issue of file relocation, made for some of the best compatibility with various ROM versions and the gave the option to have various options for the patch; a graphics translation might translate graphics that are for the most part decorative, rather than having to make an executive decision you can just make an option at the patch level. The main downside is that it might well be platform specific, require multiple batch files to be made or require runtimes to be installed. Can also help where files are encrypted or compressed and by making a patch you are still technically redistributing code that does not belong to you (encryption and compression looks like differences to a basic compare function).

Some people took this custom format concept a step further on the Wii and some other consoles by making a kind of jump loader using a dashboard/menu level console hack to apply a patch to a game’s data when it was held in memory. This also had the added bonus of allowing those with the original game and an otherwise unhacked Wii to play the hacked game. Nintendo would do a similar thing to patch a bug in Wii sports resort as the Wii lacks a real patch management feature like the 360 and PS3.

## File systems and operations

This section will detail the tools and general methods of operation of said tools to pull apart/unpack/extract ROM images. It will probably also be the only section to cover systems other than the GBA and DS in any real detail. The general form of this section is device name, name of method by which hacked code can be run and whether it can be emulated, the names/extensions/types of binaries, any hardware documentation and finally techniques to parse file systems. For additional information or information on systems not covered here then the main sources of hardware information and such like are typically homebrew developers, those wishing to run various flavours of Linux on consoles and emulator authors.

### 1.4.1 Non filesystem devices

Method - usually flash carts of various forms which may not exist in an up to date form or be quite expensive if they do exist. Emulation is usually available and very high grade if you want it to be and beyond that everything up to the late 16 bit era and slightly beyond can usually be emulated on newer consoles and handhelds at some level.

As the GBA is a focus of this guide it gets a proper section but in general devices that are older than the DS or do not use optical media will tend not to have a filesystem, this means you get to employ various techniques covered in the GBA section below. They are frequently directly accessible in memory but other than the GBA often have quirks you have to address (mappers in the NES, hirom and lorom in the SNES and Memory Bank Controllers on the original gameboy and GBC). It should be noted that these quirks often afford serious extra capabilities but as well as being hard to deal with they are often extremely difficult to add or remove from a game.

Today other than the GBA you will tend to only encounter a lack of a filesystem when editing the executables for things (although that is not a certainty) and if you get into editing the security/secondary processor/hypervisor programs for the consoles (things like IOS on the Wii and security code for the PS3 Cell coprocessors).

[romhacking.net](http://www.romhacking.net/?page=documents&category=12&platform=&game=&author=&perpage=20&level=&title=&desc=&docsearch=Go) maintains a database of hardware information for older consoles and some newer ones. You may also like [infrid.com for the N64.](http://infrid.com/rcp64/documents.php)

### 1.4.2 GBA

Method - flash cart or emulator.

The GBA is self contained but the executable location (or start thereof and start of the useful stuff) is easily found.

[GBAtek](http://problemkaputt.de/gbatek.htm) and [CowBite](http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm) are usually considered to be the top hardware documents, some more specific documentation for certain hardware areas like the audio setup also exists.

Aside from some homebrew the GBA does not really feature a file system meaning there is not really such a thing as exploding the ROM image into a group of files it is composed of. There is an advanced technique known as tracing though that can find where any data is located in the ROM and a handful of simpler, though sometimes less effective, variations on the theme (BIOS SWI call logging and pointer field searching) that will be covered in the appropriate sections.

Some tools like those seen in Atrius’ Golden Sun editors contain searching routines for subfiles, compression can be searched for with various tools, the GBA “sappy” audio format such that it is can be detected in some cases and more general tools for games like Pokemon will also contain a listing of the location of various game components (or the things that point at them) as might some other games. Other than flash carts, some undumped ROM images (full length videos) and some of those 30 in 1 carts you find in tourist traps the whole cart is visible in memory at all times and that means the space limit is 32 megabytes.

### 1.4.3 DS

Method - flash cart or emulator. DS and DS lite run GBA code natively if you have a GBA slot cart.

The executable formats for the DS are ARM9, ARM7 and overlay files that usually come with the extension .bin and sometimes SRL.

[GBAtek](http://problemkaputt.de/gbatek.htm) is the main reference document for hardware for the DS.

NDStool

[NDStool on filetrip](http://filetrip.net/nds-downloads/utilities/download-nintendo-ds-rom-tool-ndstool-1501-f29352.html) Command line and very quick and easy but fails to rebuild certain ROM images properly (most still work).

Nitroexplorer

[Nitroexplorer filetrip](http://filetrip.net/nds-downloads/utilities/download-nitroexplorer-2b-f7301.html) Built to make up for shortcomings in NDStool methods. Short of manual editing the go to tool for most.

NDSTS

[No-Intro tools page](http://www.no-intro.org/tools.htm) Able to extract files and insert files of the same size (you can pad them if you want), if it crashes when you have edited it where it worked before with this then it is definitely your fault.

Crystaltile2

[Crystaltile2 filetrip](http://filetrip.net/nds-downloads/utilities/download-crystaltile2-20100906-f23649.html) Able to parse the DS file system as well as extract individual files. Support at this level for compression as well as certain container files as well as support for all sorts of known formats and additional functionality. Click the DS icon on the the icon bar to open the viewer.

Tinke

[Github link](https://github.com/pleonex/tinke/) A tool similar in capability to Crystlatile2 and also supports decompression of files, in ROM and extensive support for other formats.

The DS filesystem is well known and well understood so you have many more options here, indeed it is usually the first feature aspiring DS ROM editing tools gain. DSi compatible games can usually be parsed by standard tools and DSi specific code should now have relevant keys to help things there although it can not really be run. Most games will have archive formats for a handful of files stacked on top but a handful of DS games have been observed to use large single archives for all or most of their files with the files not put into the archive usually being download play components, sound or video.

Most usage will be covered or fairly obvious save for ndstool which has a basic extraction command like

“ndstool -x *.nds -9 arm9.bin -7 arm7.bin -y9 y9.bin -y7 y7.bin -d data -y overlay -t banner .bin -h header.bin”

Replace the -x with -c and the *.nds with a valid name and you can reconstruct a ROM. NDStool is not that useful for end stage hacks but quite useful for quick tests. “ndstool -l *.nds” will make a file listing of the files inside a ROM and their locations.

### 1.4.4 3DS

Various hacks, though things are frequently in a state of flux as it is a modern system that can be updated. Trend is towards custom firmwares, though flash carts also exist. Decryption of whole games is possible, see XORpad and such like, and may have standalone methods before long. Decrypted ROMs may be avaialable online and some files can be obtained from [memory dumps](http://gbatemp.net/threads/3ds-cwav-dumper.361437/).

Running modified code is well within the scope of the hacks capable of running copied versions of the games.

[3dbrew](http://3dbrew.org/wiki/Main_Page) is the main documentation on the 3ds hardware. A quick overview says it shares a lot of its history with the DS but it is also somewhat closer to a full modern computer architecture (hypervisors/kernels, segmented memory and the like), also features an opengl like implementation of 3d.

### 1.4.5 GC (gamecube)

Method - mod chip and miniDVD/modded case and regular DVD, SD loader, IDE adapter. Emulators demanding but viable.

boot.dol is the main executable format.

[Hitmen YAGCD](http://hitmen.c02.at/files/yagcd/yagcd/frames.html) is generally considered the better gamecube hardware document.

[GC tool](http://filetrip.net/wii-downloads/other-files/download-gc-tool-120-beta-f818.html)

[GCM utility](http://filetrip.net/wii-downloads/other-files/download-gcmutility-05-f606.html)(mainly multiboot rather than iso handling).

[Gamecube ISO tool](http://filetrip.net/wii-downloads/tools-utilities/latest-gamecube-iso-tool-f28774.html)

### 1.4.6 Wii

Method - Softmod loading from external USB. Modchips and some softmods support gamecube. Emulation demanding but viable.

[Wiibrew](http://wiibrew.org/wiki/Wii_Hardware) houses the main collection of hardware information and information on software internals although there are others that move more into formats and editing of internal software.

.dol is again the main format although ELF appears in homebrew.

Wii games and files come in two original flavours and one used by some iso loading types.

Discs Several tools available but Wii scrubber will be the method of choice here

[Wii scrubber filetrip download](http://filetrip.net/wii-downloads/other-files/download-wiiscrubber-kit-with-multiloader-140-f4399.html)

You might however also consider [Wiimms ISO Tools](http://wit.wiimm.de/) for a nice command line alternative and support for some of the custom formats that became quite popular on the Wii.

Virtual console and Wiiware aka WAD files Not to be confused with doom wad files.

One of the former tools for this was WWpacker but better examples exist in

[libwiisharp example binaries](https://code.google.com/p/libwiisharp/). Simple tools but can unpack things well.

[showmiiwads](http://code.google.com/p/showmiiwads/). A GUI tool featuring the ability to unpack wad files and deal with common things done to the files they contain after that.

Many titles also nest things in a format known as u8 (and often combine it yaz0 compression) but both of those tools can extract, decompress and deal with that as well.

[https://github.com/BtbN/libwiisharp](http://libwiisharp%20github%20page)

[showmiiwads github page](https://github.com/Plombo/showmiiwads)

HDD Most people do not use whole iso images or the minor tweaks to them any more and will instead use a USB hard drive and maybe a custom format. These come in various formats and layers of support but WBFS is the main method that is often stacked on top of FAT or NTFS filesystems. Wiimms ISO Tools linked above have a measure of support for some of this.

### 1.4.7 Xbox

Method - Softmods and hardmods both using minor variations on the idea of internal hard drive or copied DVDs. Emulation not really game playing grade for most things but getting better, the 360 does feature a measure of hacked xbox game support when properly hacked.

The executable format for the 360 is xbe files.

As with most things here there are several options although three go head to head here.

C-Xbox tool

Qwix

Craxtion

[Filetrip download (all three)](http://filetrip.net/oldies-downloads/xbox/iso-hacks-tools/)

### 1.4.8 Xbox 360

Method - no real softmod. DVD mod (does not allow altered games, XBLA or DLC unless combined with one of the following methods), JTAG (required older hardware) and RGH (can be done on most hardware though later updates can be harder to work around) lead to onboard and USB loading. Emulation nowhere near.

[Free60](http://free60.org/Main_Page) features a lot of hardware information.

Xbox 360 games come in two broad flavours with a third method mentioned. The executable format for the 360 is .xex files. These can be extracted further (they are based on the Windows PE/portable executable format used in exe and dll files).

Xex Xextool and xextool GUI are tools that can help here. They can unpack the format, apply various patches both to the files themselves and apply the title update patches.

[Xextool filetrip download](http://filetrip.net/360-downloads/iso-tools/latest-xextool-f29383.html)

[XextoolGUI filetrip download](http://filetrip.net/360-downloads/iso-tools/latest-xextool-gui-f29384.html)

Discs Various programs will extract things, including the ISO checking tool known as ABGX360, but many are unwieldy so e-xiso is the main go to method.

[Extract xiso homepage](http://alecsis.free.fr/Extract-xiso/)

[Filetrip download](http://filetrip.net/360-downloads/iso-tools/download-e-xisogui-1007-f28976.html)

GOD and NXE/hard drive installs have come from discs and have but a few bytes difference between each other. They can be made back into more or less unusable isos with GOD2ISO.

XEX files are the binaries of the 360, there can be several. Patches exist in the form of title updates and can be applies to the XEX files if you really want.

XBLA/DLC PIRS, LIVE and CON. PIRS are signed by MS and can be installed on any 360 without issue. They are mainly sourced from Bethesda game of the year and Borderlands double pack games but there are several more.

LIVE is the format of XBLA and DLC. XBLA demos are full games but a little string is swapped to allow play of the full one (naturally this breaks signing and needs a developer or JTAG/RGH box to run it).

A related set of formats and usually handled by all the same tools. Le Fluffie is one of the main ones.

[Le Fluffie download page](http://skunkiebutt.com/?page_id=362)

[Filetrip download](http://filetrip.net/360-downloads/other-files/download-le-fluffie-690025-f28975.html)

USB Not really a format but one of the main methods of access so it is noted. Later in the life of the 360 Microsoft added support for a custom USB format (in practice it was a reserved section of a USB drive). XTAF.

Supported by several tools but USBXTAF is the main method.

[Filetrip download](http://filetrip.net/360-downloads/hdd-tools/download-usb-xtaf-xplorer-44-f23780.html)

### 1.4.9 PS1 and PS2

PS1 - modchip. Emulation available for many years, though can be tricky if you venture into the often superior plugin based emulators.

[Playtown](http://www.geocities.co.jp/Playtown/2004/psx/) has a lot on the PS1 (mainly in Japanese). The romhacking.net link from other systems has a bit of information and [psx.rules.org](http://psx.rules.org/psxrul2.shtml) has some more.

PS2- modchip and some softmod driven network/USB loading possible. Emulation demanding but viable.

[philvaz.com](http://www.philvaz.com/games/PS2.htm) has some good information on the graphics hardware and some internals. [scee.net (warning PDF link)](http://research.scee.net/files/presentations/agdc2002/PS2forPCprogrammers.pdf) has a nice introduction as well.

ISO 9660 was for many the order of the day but later games on the PS1 and many on the PS2 added a dummy setup to that and instead made a new filesystem later on and/or read addresses directly from discs.

For the most part the PS2 was also a standard iso 9660 image that countless tools from the likes of 7zip upwards can open but certain games (most notably Square Enix games for music) used raw LBA reads or a custom file system to read certain parts of the iso images in question. There are a few tools that attempted to detect the signature of the music files and occasionally within the whole image.

LBA reads were also used in anti piracy protection for many of these games.

Both use a version of the executable formats known as ELF as their executables.

### 1.4.10 PS3

Method various- softmod (maybe with hardware trigger) leading to USB and hard drive loading. Emulation nowhere close.

Technically the PS3 uses a version of ELF for the executables.

ISO

PUP files (updates)

DLC and PSN content.

### 1.4.11 PSP

Method - softmod loading from memory card (official Memory Stick PRO Duo or microSDHC adapters available) or loading from onboard storage (PSP Go). [Emulation more possible than before](http://www.ppsspp.org/) but undeveloped compared to many other systems.

[PSP MIPS R4000 processor (warning PDF)](http://groups.csail.mit.edu/cag/raw/documents/R4400_Uman_book_Ed2.pdf) is a system developer level breakdown of the PSP processor.

Executable format pbp format (usually called eboot.pbp).

There are a few tools here but UMDGen is the dominant one and there is little reason to use another. It supports extraction, insertion of any length, rebuilding the file locations table and relinking files as well as creation of compressed images.

[Filetrip link](http://filetrip.net/psp-downloads/tools-utilities/download-umdgen-400-f6743.html)

### 1.4.12 Saturn

Method- Modchip for the most part. Emulation surprisingly good, though the architecture of the Saturn means emulation is demanding for the relative age of the system.

[Yabause](http://wiki.yabause.org/index.php5?title=Main_Page) (one of the more popular emulators for the Saturn) has a fair bit of hardware information.

A slight variation on the iso format although doable with standard tools.

[Guide involving the manipulation of saturn files](http://www.rockin-b.de/saturn-patching-enemyzero.html)

### 1.4.13 Dreamcast

Method - Simply insert copied disc or use a disc loader known as “Utopia”. Emulation not bad for some games.

Disc image handling varies. CD burners were a new concept when the DC was released and there were lots of competing formats for optical media, you will then want a standard iso tool to explode it into the component tracks (the good stuff is typically the third track onwards). The tracks function more or less like standard isos, save for the fact that they are offset and most normal iso tools can not handle this as is. Fortunately Iso LBA Fix (isofix) by DeXT exists and will change the LBA to start from zero at which point everything will handle it.

[dextremes.com](http://dextremes.com/dc/data/index.html) has links to some information.

### 1.4.14 Amiga

Method - copied discs. Emulation well developed.

ADF images are the most common (ADZ are just zipped versions of ADF) but being sourced from floppy discs they tend to have a filesystem.

[amigadev](http://amigadev.elowar.com/) has a lot of top quality information.

UnADF should allow you to unpack ADF images.

[Unadf homepage](http://lclevy.free.fr/adflib/unadf.html)

[Filetrip link](http://filetrip.net/pc-downloads/applications/download-unadf-10-f25764.html)

### 1.4.15 PC and related hardware.

Method- you control the hardware so disc emulation, cracked executables or method emulation (see Steam emulation)......

Various executable formats depending upon development language and operating system.

A tiny bit more on PC hacking is mentioned later but for simple unpacking.

PE

Windows main format is the PE format which is usually known by the extensions exe and dll. This can be unpacked with many things including the likes of 7zip.

ELF

Used as the basis for a lot of executable formats (including many of the consoles covered elsewhere).

Iso

Broad term for images of optical discs (and sometimes other things) and there are various formats for it (many things will be called iso and burn as one but be unable to be extracted). Can be extracted by many tools including [7zip](http://www.7-zip.org/) and [Ultraiso (paid software)](http://www.ezbsystems.com/ultraiso/)

Batch/bash

Most operating systems provide a command line where commands can be typed and layered on top of this is are the concept of small text scripts that can do fairly extensive things but in practice are just a list of commands with a few extras.

Scripts

(Python, lua, Java, visual basic and many more). Many programming languages operate outside the realms of the standard executable (or have it for a wrapper) and can have their original code, or something close to it, recovered by various means.

SD/CF/XD

A points you may have to copy a SD,CF, XD or some other memory card at the sector by sector level. On these occasions there is a program called DD which is popular on linux and has a [Windows port](http://www.chrysocome.net/dd) too.

## Finding the object of your interest.

Games come as ROM images, or if they come from optical media originally then ISO images, but common to both is that they are one large lump of code. The previous section took care of methods to pull apart these initial files but that is only the start of things as you will want to find the relevant file or section that houses the thing you want to look at or change.

There are techniques here ranging from the obvious to the subtle, from the basic to the complex and from the crude to the precise and many will be useless to you without knowing several other things detailed elsewhere in this document. Many ROM hackers starting out will see the more advanced methods of locating data and panic but for the likes of the DS and most other file system sporting devices the main method people use to find the files they want is the file names (most games feature them even if they do not use them directly), file sizes and extensions either directly (English.bmg might well be the text in a DS ROM) or indirectly (sound_data.sdat will probably be the sound so you can eliminate that chunk from your search for the text for a game which is doubly nice as sound is usually a good portion of space in a ROM) with a quick look at directory names alongside that (sound will probably contain sound, 3d will probably contain 3d and dwc\\utility.bin is probably download play[2](romhacking20203.html#fn2x0) ).

Alongside this there are several known extensions and header values for various formats where the first few bytes decode as a known ASCII or hexadecimal string. Many more examples later but for now sdat is an extremely common sound format on the DS and bmg is a fairly common text format. It should be noted that extensions can often give away the presence of compression with common examples being if a file ends with “.l” , “.lz”, “._” or something along those lines, especially if it has another known extension before it, then it might well be compressed and you can act accordingly.

ROM corruption should also be mentioned here. It gets a bit costly to do if you have to burn discs each time but when emulators and flash carts are available you can corrupt a part of the ROM, run it and when it errors or crashes you get to see what parts do what. The simple method is to use one of the hex operations you learned about earlier but there are dedicated corruption tools. Likewise the technique might need to be refined for certain things as things like graphics can only use a select series of values that the corruption tool might inadvertently use. You can also refine the concept to a point where alteration is probably a better term, for instance when trying to figure out how text is encoded it can be useful to repeat a value or sequence rather than using random garbage.

After this you start heading towards more programming level techniques like relative searching which uses the fact that in Roman character using languages A is followed by B which is followed by C and so should you know the word CAB is in a ROM you can search for a string what has one value followed by a value two less than it and that followed by a value one less than the opening value (although in practice a longer search term is more useful).

Tracing is understood to the be the ultimate method and it is still quite different to simple hex analysis and file names, however it is not that hard to follow along with the basic idea. In tracing you find the thing you want to look at in the memory (if it is on the screen or coming out of the speakers then it is likely in memory), find what put it there, find where that was told to look and so on until you have the location of the file in the ROM or enough data to find it, and possibly also the means by which it is all decoded. Naturally it is quite an involved technique but very accurate and very reliable. When dealing with PC games and to a lesser extent with some emulators you can observe which files are open and loaded when running the game but this is not always available/viable for the consoles. There is the lesser method of watching BIOS calls (BIOS often being used to handle compression can lead you right to the location on the GBA) and you can do things like search for a field of pointers (on the GBA this often means a list of 08 with 3 bytes afterwards as the most common GBA address is of the form 08XXXXXX) which can help.

## Abstraction

Certainly a topic worthy of a document all to itself the main idea here is related to the jargon earlier. Coming at the cost of not being immediately accessible to all (or in this case the computer in question) you build a method by which to interpret something into a format understandable by a target, in this case usually the console in question which translates it to a usable format. Such a move obviously has speed penalties, the bonus however is that you can use a simpler method to store, deal with and hopefully change your chosen item as necessary.

Programming languages are all about this as they all attempt to move away from a user feeding the computer a string of 1s and 0s. A nice example might be to compare the GBA and DS for if you recall the GBA lumps everything into one file where the DS can explode a ROM into a series of other files. Now if you want to add a section of code to the GBA you either change all references to everything after the section you are increasing in size accordingly (a very tedious process that nobody ever does) or add to the end of the ROM (or some other blank space). On the DS your ROM rebuilding tool simply adds the extra to the locations of the subsequent files (and other sizes as necessary) and as the files are not usually tied to each other as whole (obviously files can work together on occasion) nothing is troubled. However when compared to the GBA it does mean the DS will have to do an extra step when it comes to running the ROM to figure out where to point the read command. Much like a unified theory of physics there exists a theoretical but perfect level of abstraction that you could feed an initial value into and have it run accordingly but much like physics you occasionally want to get some actual work done so you cut it off and possibly simplify/restrict things so as to set about getting that something done.

Related to this is that not all the data you see in a ROM will be used in it. For instance any file names contained within subfiles or occasionally even the files themselves might be completely irrelevant, as might be some of the pointers/size values. Generally though it pays to know and understand what each value might mean and account for it as you edit the files unless you can demonstrably prove it does not matter.

This also applies in reverse with some developers choosing to hardcode values somewhere despite not having to or it even being all that good from a programming quality standpoint (as a ROM hacker you might well have to fix several bugs introduced in such a manner); remember that game programmers are people too and are no strangers to the hack something together and knock off for lunch routine.

If a rule of thumb has to be made it would be understanding the level just above the thing you are trying to do will tend to be beneficial and such a logic underpins a lot of the content of this document.

## Tools of the trade continued

The following simply lists some example tools as there are usually several options for a program to tackle a task, some very basic usage and some screenshots where necessary. In the case of large tools or area specific tools the proper usage will be covered in other parts of this document where there may also be other little tools to help out things. Basic usage of programs to parse relevant filesystems was already covered and will not be covered here. With the exception of the paid hex editors, a couple of audio programs, the debugging/reverse engineering tool known as IDA (a big exception) and some of the translation memory/CAT tools all the programs covered are freeware, often even open source, and everything can be done with the open source/freeware programs.

### 1.7.1 Hex editor

As part of the underlying project this document is part of several hex editors were tested and rated for their usefulness so as to come up with a shortlist. Most ROM hackers will have several at their disposal with each aimed at different tasks. However if you can pick a paid one, get the four freeware suggestions and get a ROM hacking specific one most things can be done with relative ease. In short though a hex editor is a hex editor and everything else is so much extra that could one day make your life slightly easier. The GUI for most of these is extensively customisable but for the most part the images are those of the stock editor with a few menus displayed as appropriate.

The features that make life easier for ROM hackers are

* Bitwise operations
* Boolean logic/operations (sometimes lumped in with bitwise operations)
* Byte flipping
* Search and search all
* Search and replace
* Hex distribution
* Operations on selected areas (some editors will only operate across the whole file)
* Scripting
* Format/structure listing support
* Variable width windows
* Undo/Redo
* Insert
* Hash values including custom options
* String dumps (occasionally you might just want every string in a game even if inserting it back in will be a pain without the surrounding info)
* Custom character encoding support
* Compare files (including size differences/inserted section support)

Raw disk editing, program/memory editing, X86 disassembly, base64 decode and similar things are other features that an editor might be sold as having are great but they have been of limited use to ROM hackers in the past, even program/memory editing is usually taken care of by specialist programs as you will see when cheats are discussed.

Paid The freeware editors in many ways provide a more than adequate replacement for the commercial tools but many still like the commercial offerings. The two best ones are quite pricey and are roughly equal in ability.

Hex workshop [Hex Workshop homepage](http://www.hexworkshop.com/)

Probably the most popular paid editor among ROM hackers.

![PIC](images/1_home_fast6191_romhackingguide_unrenamed_files___mhackingguidehexeditorsshowcasehexworkshop1.png)

010 editor [010 editor homepage](http://www.sweetscape.com/010editor/)

Another paid editor on a par with hex workshop

![PIC](images/2_home_fast6191_romhackingguide_unrenamed_files___romhackingguidehexeditorsshowcase010editor1.png)

Freeware The freeware offerings here, unlike some other areas of computing, are not on a par but with a slightly different GUI. However when the suggestions in the freeware category are combined it makes for all the functionality of the commercial offerings.

ICY Hexplorer [Sourceforge page](http://hexplorer.sourceforge.net/)

Almost at the level where you could drop it in as a replacement for the commercial offerings (save for the lack of ability to have multiple files open at once). Needs some setup to get the GUI functioning well but once done it is suitable for use as a day to day editor.

![PIC](images/3_home_fast6191_romhackingguide_unrenamed_files___hackingguidehexeditorsshowcaseICYHexplorer1.png)

XVI32 [Homepage](http://www.chmaas.handshake.de/delphi/freeware/xvi32/xvi32.htm)

Still being actively developed and it is mainly here as it features a powerful scripting language which can accomplish most tasks the paid and function heavy freeware editors sport with a bit more after that owing to it being a true scripting language.

![PIC](images/4_home_fast6191_romhackingguide_unrenamed_files___rs_romhackingguidehexeditorsshowcaseXVI32_1.png)

Tiny Hexer [Filetrip download](http://filetrip.net/pc-downloads/applications/download-tiny-hexer-1816-f29009.html)

A discontinued editor but has some very impressive features the equal of, and sometimes even better than, the commercial offerings.

![PIC](images/5_home_fast6191_romhackingguide_unrenamed_files___romhackingguidehexeditorsshowcasetinyhexer1.png)

HxD [Homepage](http://mh-nexus.de/en/hxd/)

[Filetrip download](http://filetrip.net/pc-downloads/applications/download-hxd-hex-editor-1770-f12907.html)

Probably the simplest editor on this list but the go to freeware editor for a lot of people.

![PIC](images/6_home_fast6191_romhackingguide_unrenamed_files___rders_romhackingguidehexeditorsshowcaseHxD1.png)

ROM hacking specific As wonderful as the editors, commercial or otherwise, above are they lack things like high grade table support (most of the above will support a measure of custom characters but nothing truly custom like that which is seen in hacking) which is fairly essential for text hacking purposes.

Crystaltile2 [Filetrip download](http://filetrip.net/f23649-CrystalTile2-2010-09-06.html)

Supports many character sets out of the box and more importantly supports table files.

Lacks boolean manipulations along with the standard hex operations and seemingly fixed to 16 bytes per line.

Has a very good relative search (perhaps not quite as friendly as monkey moore but it works and goes right to up 4 byte/32 bit search as well as many other text grade features covered later)

Has a compression search (mainly type 10 LZ and lesser support for type 11 LZ and huffman).

CRC 16 and 32 are available and can be focused on a selection.

DS filesystem support and header viewing, top flight tile editor/viewer, full ARM9 and ARM7 as seen on the DS disassembler

Support for a fair few SDK and common formats (NARC, SDAT, NFTR, DS 2d formats, some general archive formats)

![PIC](images/7_home_fast6191_romhackingguide_unrenamed_files___ackingguidehexeditorsshowcasecrystaltile2_1.png)

Windhex32 Not to be confused with the popular disk forensics grade hex editor “[winhex](https://www.x-ways.net/winhex/)” which is not in the paid list owing to a lack of bitwise features and similar things (it is very good at disk forensics though).

[Romhacking.net page](http://www.romhacking.net/utilities/291/)

Great table and text support (including multitable support you can switch between), some SNES specific memory mappings and SNES/NES tile editor. Mainly just a very nice text capable hex editor with table support and some tools to complement that. It lacks undo support and some GUI choices are a bit odd which prevents it from being a drop in replacement for HxD.

![PIC](images/8_home_fast6191_romhackingguide_unrenamed_files___omhackingguidehexeditorsshowcasewindhex32_1.png)

![PIC](images/9_home_fast6191_romhackingguide_unrenamed_files___omhackingguidehexeditorsshowcasewindhex32_2.png)

Goldfinger [Romhacking.net page](http://www.romhacking.net/utilities/204/) Not to be confused with the GBA assembler Goldroad, the common translation of the Chinese term for cheats or the the common translation of the Chinese term for cart pins.

Support for 9 tables at once, it does not come with ASCII readout as standard so you will have to find/make one. It does feature some table editing abilities.

Although not quite suited to full text display it is unlike most other editors in that it is not necessarily bound by the end of the line. This makes it a nice choice for text editing without having to make a custom tool or dump the text and attempt to get something done in a more conventional text editor.

![PIC](images/10_home_fast6191_romhackingguide_unrenamed_file___omhackingguidehexeditorsshowcasegoldfinger1.png)

Translhextion [Romhacking.net page](http://www.romhacking.net/utilities/219/%20)

New fork/version [Romhacking.net forum thread](http://www.romhacking.net/forum/topic,14373.0.html)

For many the standard ROM hacking hex editor for a long time now (although crystaltile2 is edging it out a bit).

Adjustment of hex window size possible via editor but not grouping.

Jump including relative jump support available and can manipulate bits

Can search using tables and relative search support is available.

No undo support but a nice read only option by pressing tab.

![PIC](images/11_home_fast6191_romhackingguide_unrenamed_file___ackingguidehexeditorsshowcasetranslhextion1.png)

### 1.7.2 Tile editor

Although you can edit anything with a hex editor it gets very complex to do anything other than the most basic editing using one and the first thing to move to a higher level tool is 2d graphics which get a tile editor. There are several available although only a handful will be focused on here. Various homebrew development kits have some nice programs as well aimed at conversion from common formats to the somewhat odd formats used by the handhelds and other consoles.

Crystaltile2 [Filetrip download](http://filetrip.net/f23649-CrystalTile2-2010-09-06.html)

Features one of the best tile editors out there (support even for the odd custom hardware display formats and a tile editor capable of being set to arbitrary widths) and has support for various DS image formats on top of the DS file system itself. Exporting and importing images is also possible.

![PIC](images/12_home_fast6191_romhackingguide_unrenamed_file___kingguidetileeeditorsshowcasecrystaltile2_1.png)

TileEd2002 [Homepage](http://home.arcor.de/minako.aino/TilEd2002/)

[Filetrip download](http://filetrip.net/gba-downloads/tools-utilities/download-tiled2002-064b-f7846.html)

A GBA vintage editor but as the GBA and DS hardware are largely the same it can get far. It can do basic sized tiles in the two most common hardware formats and has a nice palette fiddling option (one colour at a time if you want), something which some of the others lack and thus is useful when trying to figure out what amount of padding a palette format uses. Lacks support for highly custom tile sizes (it will crash if you try on GBA format imagery) although it does support loading of savestates to get palettes directly from those. Note also the use of imagery to display text as opposed to a text rendering engine; such a thing is very common in smaller puzzle games where there is not much need for actual text, for use in stylised text and in menus in general.

![PIC](images/13_home_fast6191_romhackingguide_unrenamed_file___hackingguidetileeeditorsshowcasetiled2002_1.png)

Also the palette as held in the GBA.

![PIC](images/14_home_fast6191_romhackingguide_unrenamed_file___detileeeditorsshowcasetiled2002VBApalette_1.png)

TileGGD [Github page](https://github.com/barubary/tiledggd)

[Romhacking.net download](http://www.romhacking.net/utilities/646/)

Although the above two should do for most editing purposes this program has hugely customisable support meaning most conceivable hardware formats should be covered (from 1 to 32bpp with big and little endian support) and in some ways has a slightly nicer user interface than crystaltile2. Unlike the other two there is no editing capability built into the program but there is export and the information can be used to direct an editor of another program.

![PIC](images/15_home_fast6191_romhackingguide_unrenamed_file___romhackingguidetileeeditorsshowcasetileggd1.png)

### 1.7.3 Spreadsheet and command line

The following is a few basic tools that can be used to help out when ROM hacking when existing tools fall short and before/instead of jumping to programming a game/format specific tool.

Libreoffice usage [Office suite homepage](http://www.libreoffice.org/)

[Calc usage/help page](http://help.libreoffice.org/Calc/Welcome_to_the_Calc_Help)

Calc is the libreoffice spreadsheet program and it supports hexadecimal after a fashion. It is certainly no substitute for a fully realised programming language but it has proven quite valuable when making quick and dirty scripts or reverse engineering formats.

There are seven main operations that get done beyond the basic addition, subtraction and multiplication.

Pasting At least one of your hex editors should have a text export option that when you have set the appropriate amount of columns can export a text list of the hexadecimal (effectively making an array) and equally a search option should be able to export the results. Either way you will need to paste this into the spreadsheet which for the most part is fairly intuitive and automated but you will occasionally have to import as a fixed width or as a delimited set of text (usually a space or tab doing the delimiting). Merging cells (say for a 32 bit value spread across 2 columns where you do not want to change your editor’s behaviour) can be done but the quick and easy way is to paste the columns into a text editor and search and replace for the delimiting value.

If you must though you are better off abusing a maths function and multiplying by the appropriate hexadecimal value (65025 and 255 to shift the hex equivalent by 2 and 1 bytes respectively) and the reverse using mod, floor and other functions.

Bitwise, boolean and flipping operations are best done in a hex editor and given the option you will also want to import as text (all the functions will still work) as numbers have a habit of being parsed to something.

Fill A basic command/option but not one everybody knows about. In the bottom right corner of a given cell when selected there will be a small square which you can click and hold before dragging down or up (or across) and the cells have the contents replicated in the cells covered by the drag range. If you have a pattern it will tend to be continued and if you have a formula that will tend to be continued but the cell contents aligned to the same thing (if the original was c4 - c3 the next will likely be c5-c4), it is not foolproof and some of the more advanced things you want want to do can be tricky to pull off but it has worked far more often than it has not.

Dec2hex and hex2dec Although calc does support hexadecimal and you can combine items into one function it is usually easier to have the initial hexadecimal values, the decimal equivalents and the conversion back again.

In calc the commands are dec2hex to convert from decimal to hexadecimal and hex2dec to do the opposite.

Differences Granted this is more of a technique than an actual function but it is the most used concept that actually changes/generate data. If you have a field of pointers (covered later but the general idea is a value that contains the location of another value) and the results of a search for something that indicates the start of a value you might need them to line up but it might not be readily apparent. Most of the time with pointers values change between them (if the data is a fixed distance apart there is no need to incur the time penalty for looking up the pointer and maybe doing some operations upon it) and this can give things away. To do this simply take the next pointer value and subtract the current one. The result will be the difference and if you do it for an unknown pointer set you can quite easily match things up and determine if they are “out” by a given amount. You can do a similar thing in reverse to generate new file lengths to save calculating and changing an entire pointer table by hand but by this point it is probably better to build a proper program.

Rounding function As mentioned data tends to like to be found at 8,16 or 32 bits or some other interval (several file formats on the DS have been observed to align to an address that is a multiple of 100h). CEILING is the main function here although remember it takes decimal input for the number to round to. MROUND can also be used in a pinch but remember it can also round down which would be bad so best to add an amount if you are going to use that.

Sort function Not quite so useful in ROM hacking as it is in day to day use is the ability to sort by a value (either letter order or number order)

True/false queries and parsed data Humans are not so good at recognising and interpreting numbers at pace but nice coloured squares are a different matter and quite possible in various spreadsheets. Still if you must use numbers 1 and 0 are easier to account for than lengthy values and spreadsheets can then help with this. The basic method uses the IF command and is typically formed “IF(some value/cell, equals/is less than/is greater than, then FALSE/TRUE)” but deleting as appropriate.

Filecutter [crackerscrap.com (click on downloads)](http://crackerscrap.com/)

Usage: filecutter file.in length file.out &lt;-s start&gt;

As windows lacks the ability to slice up files from the command line you have this program. Once you have your list of addresses you can use this to generate a batch file with the addresses as the arguments and although it will be specific to that incarnation of the file (not such a problem if you just need everybody to slice up the file as it comes from the ROM) you have just built an archive unpacker. If you need to couple it with a decompression tool you can do that as well in just a few extra steps back in the batch file stage.

Input is in decimal by default but hex can be used if you stick 0x in front of the relevant numbers.

Getmyhex [Romhacking.net download](http://www.romhacking.net/utilities/504/)

[Filetrip download](http://filetrip.net/pc-downloads/applications/download-getmyhex-1500-f29200.html)

A simple tool to get the hexadecimal readout of various short sections of text.

Radare(2) [Project homepage](http://radare.org/y/)

Now taking the place of the Romulan program featured in earlier editions. It is a scripting language but not quite, it is aimed at reverse engineering purposes though the focus is more on the PC and related platforms.

### 1.7.4 Compression

Compression was once the bane of ROM hackers but it got a lot easier to handle on the DS and is not so bad for the GBA either. At this point it might even have reduced to making for a simple extra step using a known tool when extracting something from a ROM or putting it back in but not much else.

DSdecmp [Github page](https://github.com/barubary/dsdecmp)

Supports compression and decompression of LZSS formats seen on the GBA and DS (type 10, 11, 40 and binary/BLZ), RLE and Huffman.

Cue’s GBA DS compressors [GBAtemp thread](http://gbatemp.net/topic/313278-nintendo-dsgba-compressors/)

[Filetrip download](http://filetrip.net/nds-downloads/utilities/download-cues-gba-ds-compressors-10-f29010.html)

Also supports compression and decompression of LZSS formats seen on the GBA and DS (type 10, 11, 40 and binary/BLZ), RLE and Huffman as well as LZE (used in Luminous arc titles).

Crystaltile2 [Filetrip download](http://filetrip.net/f23649-CrystalTile2-2010-09-06.html)

Has a measure of compression support built into the file manager (type 10, type 11, binary decompression support some RLE and maybe Huffman) and support for some compression searching options. Somewhat buggy but you can learn them and play to them well enough.

GBA specific BIOS and to a lesser extent general LZ compression can be searched for as it makes fairly distinctive changes to the hex. There are also a few tools geared towards being able to deal with GBA ROM images directly and work around issues stemming from a lack of a filesystem.

GBA Multi DeCompressor [romhacking.net download](http://www.romhacking.net/utilities/431/)

Can be directed and fed VBA SWI logs (SWI being the name for the BIOS calls and as mentioned the BIOS in the GBA and DS feature decompression functions).

NLZ-GBA Advance [romhacking.net download](http://www.romhacking.net/utilities/529/)

Ostensibly a graphics editor but one with compression support and compression searching.

unLZ-GBA [romhacking.net download](http://www.romhacking.net/utilities/362/)

A slightly older tool but one of the few ones capable of compression searching.

Lz77restructor2 [Filetrip download](http://filetrip.net/gba-downloads/tools-utilities/latest-lz77restructor2-f29641.html)

A newer tool with abilities in graphics and text extraction and insertion/edition on top of the ability to search for compression and restrict those searches.

GBADecmp [romhacking.net download](http://www.romhacking.net/utilities/433/)

A simple tool to decompress and recompress data from/to a known location.

Crystaltile2 [Filetrip link](http://filetrip.net/f23649-CrystalTile2-2010-09-06.html)

Supports type 10 LZ which is the same as the GBA BIOS LZ compression. Also supports compression searching.

GBACrusher [Filetrip link](http://filetrip.net/gba-downloads/tools-utilities/download-gba-crusher-010-f28823.html)

A tool to compress files using GBA BIOS compatible compression methods like the 8 and 4 bit Huffman compressions, Differential, Run length encoding, LZ (type 10) for VRAM and for WRAM. Command line version included.

![PIC](images/16_home_fast6191_romhackingguide_unrenamed_file___hackingguidecompressionshowcasegbacrusher_1.png)

### 1.7.5 Music

Format and console specific tools will be covered in the relevant sections. However a few high level tools are useful to have.

Wave editing - Audacity [Audacity Sourceforge page](http://audacity.sourceforge.net/)

Imports most wave, PCM and ADPCM variations and features editing, some mixing ability and filters.

Tracker format - Open MPT [Open MPT homepage](http://openmpt.org/)

A fairly advanced program with support for playing, editing and exporting various tracker formats. Should have a measure of DLS support although it can be problematic. Formerly known as ModPlug Tracker which is what some tutorials written before the rename will refer to it as.

Midi specific - Anvil Studio [Anvil studio homepage](http://www.anvilstudio.com/)

A freeware program that several of those editing audio for the GBA like to use.

General editing - Awave studio [Awave studio homepage](http://www.fmjsoft.com/awframe.html)

A largely paid piece of software that can help convert files and deal with less than perfect implementations of some audio formats various game specific tools might output. Midi and DLS support is available.

### 1.7.6 ASM/Assembly

Usage is often as extensive as assembly itself but some tools none the less

Emulators (debugging/hacking grade) The following is a list of emulators that possess debug functions of a grade that is useful to ROM hacking without going to abstract methods of debugging.

DS there are a handful of emulators available but only three have any real support for commercial ROM images and debugging.

Desmume

[Desmume download page](http://desmume.org/download/)

The developer and regular versions feature memory viewers, disassemblers, VRAM, OAM and other such viewers. Also features support for GDB and [LUA type](http://wiki.desmume.org/index.php?title=Faq#What_is_this_Lua_stuff_I_see.3F) debugging as seen in high grade hacking focused emulators like [FCEUX](http://www.fceux.com/web/help/LuaScripting.html). Its cheat making options are fairly well developed nowadays as well.

no$gba

[no$gba developer version page](http://problemkaputt.de/gba-dev.htm)

The gaming version of no$gba features very few debugging features (although there are some memory editors that interface with it) but there is a debugging version, which is now free to download, available with extensive debugging abilities. Note that ROM images may well need to have their secure area encrypted to run but [eNDryptS Advanced](http://www.no-intro.org/tools.htm) should be able to handle that.

iDeaS

[iDeaS homepage](http://ciacin.site90.com/ideas.php)

Though slightly less developed than Desmume on the commercial ROM front it does however support something closer to breakpoints as seen in no$gba and the GBA emulators as standard. Function logs and run to selection command are more prominent in the debugging section though and it is not quite a full replacement for no$gba.

GBA The GBA has a somewhat larger and more featured collection of debugging grade emulators.

VBA-SDL-h

[VBA-SDL-h Homepage](http://labmaster.bios.net.nz/vba-sdl-h/)

[VBA-SDL-h sharesource page](http://sharesource.org/project/vbasdlh/)

[Filetrip download](http://filetrip.net/gba-downloads/emulators/download-vba-sdl-h-r070904a-f28914.html)

Version of the popular GBA emulator reworked to add debugging support like the ability to set breakpoints.

VBA-h

[Filetrip download](http://filetrip.net/gba-downloads/emulators/download-vba-h-172-f28913.html)

VBA-sdl-h above is geared towards assembly hacking and lacks much in the way of a GUI where VBA-h is geared towards memory viewing and cheat making.

no$gba

[no$gba developer version page](http://problemkaputt.de/gba-dev.htm)

Along with the DS the GBA is well supported in the debugging editions of no$gba.

BoycottAdvance

[Filetrip download](http://filetrip.net/gba-downloads/emulators/download-boycottadvance-028-windows-f28912.html)

Some prefer this to VBA-SDL-h and it certainly is a bit more GUI happy. It can take a bit more to get some ROM images working and some of the features are not as extensive but it does have breakpoints which counts for a lot.

![PIC](images/17_home_fast6191_romhackingguide_unrenamed_file___ackingguideemulatorshowcaseboycottadvance_1.png)

Disassemblers Disassemblers are tools that can be directed to turn machine code and related information back into assembly code. They are pretty dumb for the most part and their output will tend not even to be able to be reassembled without some modification by a human, however take the time to set one up properly for the task you want and they are invaluable.

GBA and DS Emulators will usually provide some disassembly and as they know what mode the processor is running in at the time and have various viewers for memory (video, normal or otherwise) they can be even more useful but standalone disassembly tools do exist. Note that the DS does feature a custom, albeit widely supported, compression format that its binaries can and do use.

* Crystaltile2[Filetrip download](http://filetrip.net/f23649-CrystalTile2-2010-09-06.html). Has a basic disassembler for ARM9 and ARM7 built into the program and the ability to interface with other programs.
* NDSDIS2 [NDSDSI2 homepage](http://hp.vector.co.jp/authors/VA018359/nds/ndshack.html) [Filetrip download](http://filetrip.net/nds-downloads/utilities/download-ndsdis2-223-f28977.html). A basic standalone disassembler aimed at the DS.
* arm-eabi-objdump [Part of devkitpro/GNU toolchains](http://devkitpro.org/). Not so useful on ROM images/for single files only and does not support compression but should work well if you can get it something it can sink its teeth into. If dealing with newer systems then looking at these sorts of toolchains will get you something.
* IDA [IDA homepage](http://www.hex-rays.com/products/ida/overview.shtml) Paid software, the freeware edition is quite locked down though (basically X86 or nothing). This is the go to general purpose disassembler/debugging tool and one all new disassemblers and debugging plugins/tools for various platforms tend to be written for.

Assemblers The processors in the GBA and DS are quite similar so you can usually go from one to the other. Developer no$gba and crystaltile2 feature single instruction editing and IDA has some abilities in this arena too. Also tending to be 16 or 32 bits in length you can often edit instructions by hand. This will focus more on hacker grade assemblers, mainly as programming grade assemblers have great features like the ability to create variables/human readable references and similar things by default where hacker grade ones tend to require more raw input (although armips does have a lot of niceties here).

The GBA ARM7 and DS ARM9 are very similar and the added instructions for the DS ARM9 (all of three which are not all that commonly used) you can live dangerously and switch between them. Since the earlier versions of this document ARM have risen up even further in the world (they basically own all of mobile phones and tablets) so if you are using newer tools, or ones not suggested here, then make sure you are using the right modes.

Again assembly will be covered later (including some links to the official specifications) but in the meantime [imrannazar.com ARM Opcode Map](http://imrannazar.com/ARM-Opcode-Map) has a full listing in a more readable form.

armips

[romhacking.net download](http://www.romhacking.net/utilities/635/)

[program homepage](http://aerie.wingdreams.net/?page_id=6)

A relative newcomer in the ROM hacking assembler world (the first release was back in September 2009). Geared towards GBA and DS ROM hacking (also MIPS R3000 for the PS1) it has the option to use macros, labels (global and local), can load tables so as to be able to load custom strings and something closer to C/C++ family maths than the average assembler. Owing to the way it works it has pretty good support for overlays as well.

ARMeabitoolchain

ARMeabi deals with the underlying assembler for the GNU development toolchains (although for the GBA/DS specific stuff you will want to be looking at [devkitpro](http://devkitpro.org/)).

As part of an earlier hacking project a kit was made to assemble small file fragments into things that could be dropped into the ROM. Two main methods aimed at hacking here

cracker’s ARM ASM kit

[crackerscrap.com (click on projects)](http://crackerscrap.com/)

[gbatemp download (older version)](http://gbatemp.net/up/cr-dstmt.zip)

Garmy

[romhacking.net download](http://www.romhacking.net/utilities/456/)

For the GBA you may also like [this script from Dwedit.](http://forums.nesdev.com/viewtopic.php?f=5&t=10176&start=0#p113532)

goldroad

[romhacking.net download](http://www.romhacking.net/utilities/343/)

For quite a while the main assembler available for the GBA as far as ROM hacking was concerned. It is not the cleanest tool out there but can get things done and for some armips replaced it but the above tools are now the preferred method.

armish

[Project homepage](http://common-lisp.net/project/armish/)

Written in lisp and aimed more at homebrew programming it is another assembler for the ARM processor family.

arm sdt

More of a programming assembler and features some very nice functions to help with program development. Many of the GBA homebrew emulators, and some versions of moonshell on the DS, were coded using this in preference to the GNU toolchains, something which made maintenance, forking and third party contributions more difficult in some cases.

FASMARM

An ARM plugin for the X86 and x86-64 assembler [FASM](http://flatassembler.net/). You can find FASMARM [here](http://arm.flatassembler.net/).

## Basic file format concepts

Much of the rest of this guide revolves around being able to pull part file formats and it will be covered and related back a bit to the underlying hardware and the concepts the area is based on but there are things to look for when pulling apart a file.

Identifiers

also known as magic stamps these are small lengths of usually ASCII text or hexadecimal that are “unique” to the start of a given file format, section thereof or command.

Lengths

most times the lengths of a file or the files contained within an archive format are very important to have. It need not be present if you can calculate the lengths otherwise.

Pointers

as well as lengths the locations of the files are useful to have as are the sub sections of a complex file format and these will tend to have values that state the location of them (point if you will).

Header

the start (or sometimes end) of a file that often houses information on the rest of the file.

It gets a lot more complex, area specific and there are various methods and pitfalls some of which have already been mentioned (things like word alignment) but if you can find one or more of the above and document those you will usually be well on your way to reverse engineering a file format.

Also for an example on why your hex editor will want to be able to change the size of the window (preferably when maximised and with a simple click and drag of the mouse)

Just having opened the file and then after quick resize and a tiny delete

![PIC](images/18_home_fast6191_romhackingguide_unrenamed_file___borders_romhackingguidebasicfileformatshex1.png)

![PIC](images/19_home_fast6191_romhackingguide_unrenamed_file___borders_romhackingguidebasicfileformatshex2.png)